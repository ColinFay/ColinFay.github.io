---
title: "About lazyevaluation"
post_date: 2018-07-30
layout: single
permalink: /lazyeval/
categories: cat
output: jekyllthat::jekylldown
excerpt_separator: <!--more-->
---


A follow-up on Thomas Lumley [follow-up post](http://notstatschat.rbind.io/2018/07/30/quoting-and-macros-in-r/) of Miles McBain
[post about quotation](https://milesmcbain.xyz/the-roots-of-quotation/). 

To sum up, Thomas is continuing Miles exploration of the concept of quoting and evaluation in R. Thomas speaks a little bit about lazy evaluation, and I decided to continue to explore this concept. Notably I wish to continue on this quote from the blogpost: 

> "In reality, to allow for lazy evaluation, R has a special data structure called a promise, which stores the expression until you look at it then evaluates it. R also has substitute() to get the expression out of the promise."

## Lazy Eval: a starting point

I don't have a deep knowledge about lazy evaluation so far, except common principles, [as I've already written about](https://colinfay.me/tidyeval-1/). Roughly, here's what I know so far (I'll take this article as an excuse to learn more): 

### A quick definition

Lazy evaluation is a programming concept that allows a symbol to be evaluated only when needed. In other words, a symbol can be defined (e.g in a function), and it will only be evaluated when it is needed (and that moment can be never). This is why you can do: 

```{r}
plop <- function(a, b){
  a * 10
}
plop(4)
```

Here, `b` is defined as a function argument, but never evaluated. So no error here. It's called lazy as it do "the strict minimum" of evaluation. 

Lazy evaluation means you can also do: 

```{r}
plop(a = 4, b = non_existing_variable)
```

As `b` is never evaluated, we don't have any problem. 

### Why lazyeval

Lazy evaluation is implemented in R as it allows a program to be more efficient: when you run a series of calls, only the necessary symbols are evaluated. 

### LazyData, and promises

If specified in the DESCRIPTION, datasets from packages are lazily loaded. It means two things : 

+ When `library(pkg)`, the datasets are not loaded in the environment
+ That you can "preload" them with `data("dataset")`, and get a promise back

If you run this in a fresh R session:

```{r}
library(dplyr)
data("starwars")
```

This is what you're going to get: 

![](../assets/promises.png)

A `<Promise>`. Here, as I still don't need the dataset, the symbols holds a promise to this dataset, which is sill not in memory: 

```{r}
library(pryr)
mem_used()
#Now I need starwars
nrow(starwars)
mem_used()
```

As you can see, the memory used by my R session has changed when I actually needed `diamonds`. This latter is no longer a promise, but a loaded dataset in my environment. 

But `substitute` doesn't "break the promise":

```{r}
data("nasa")
mem_used()
substitute(nasa)
mem_used()
nrow(nasa)
mem_used()
```

Here is an example of Non-standard evaluation with `substitute`: even if I'm passing `nasa` as a symbol, `substitute(nasa)` does not behave as `nrow(nasa)`. The symbol is not evaluated in the standard way, the promises is still a promises, and the symbol `nasa` does not bring the object in the environment. 

Let's just put it into a function: 

```{r}
substiplop <- function(dataset){
  # deparse turns a symbol into a character
  name <- deparse(substitute(dataset))
  paste("You called", name)
}

library(ggplot2)
mem_used()
a <- substiplop(dataset = diamonds)
a
mem_used()
```

As you can see, no `diamonds` has been evaluated. Now compare: 

```{r}
nrowplop <- function(dataset){
  paste("You called a dataset with", nrow(dataset))
}

mem_used()
b <- nrowplop(dataset = diamonds)
b
mem_used()
```

## Learning more about lazy evaluation

Ok, now, now let's dig deeper into lazy evaluation. 

### RTFM

Let's start with the beginning: the R-Manuals. `promises` and `lazy evaluation` are refered to several times in the [R Language Definition](http://colinfay.me/r-language-definition/). 

If we go to [Promise objects](http://colinfay.me/r-language-definition/objects.html#promise-objects), we learn that : 

> Promise objects are part of Râ€™s __lazy evaluation__ mechanism. They contain three slots: a __value__, an __expression__, and an __environment__. When a function is called the arguments are matched and then each of the formal arguments is bound to a promise. The expression that was given for that formal argument and a pointer to the environment the function was called from are stored in the promise.

So, what that means is that: whe calling a function, arguments are turned into `promises`. These `promises` contains: an expression, and an environment n(no value at first). In a sense, what this object holds is not a value, but a recipe for a value: "evaluate this expression in this environment", and this recipe is called only when we need it.

> Until that argument is accessed there is __no value associated with the promise__. When the argument is accessed, the stored expression is evaluated in the stored environment, and the result is returned. The result is also saved by the promise. __The substitute function will extract the content of the expression slot. This allows the programmer to access either the value or the expression associated with the promise__.

So, here's a clear definition for the `substitute` function: an "expression slot content extractor" :) In other words, when passing arguments to a function, they are immediatly turned into a promise, a data structure with an expression, with a recipe for a value. But here's the catch: thanks to lazy evaluation, you can access this expression without having to actually give an argument a value. 

Remember our fonction `plop` and : 

```{r}
plop(a = 4, b = non_existing_variable)
```

With our newly acquired knowledge, we can tell what's happening here: b is created as a promised, containing the expression `non_existing_variable`. It contains no value, but as we never try to actually evaluate (i.e. try to acess its value), there is no error. 

Let's continue on that note: `b` is created as a promise, and `substitute` allows to get the expression out of a promises. So we could modify our function to play with the expression contained in `b`:

```{r}
plop <- function(a, b) {
  cat("You entered", deparse(substitute(b)), "as `b` \n")
  a * 10
}
plop(a = 4, b = non_existing_variable)
```

But that also means we can evaluate `b` the way we want (for example to create a `dplyr::pull`-like function)

```{r}
plop <- function(a, b) {
  eval(substitute(b), envir = a)
}
plop(iris, Species)[1:10]
plop(iris, Sepal.Length)[1:10]
```

(More about environment evaluation [here](https://colinfay.me/explain-environments-eli5/))

Or, even, that we could write a `dplyr::mutate`-like function:

```{r}
mutator <- function(a, col_name_computation){
  # In three steps here to detail the process, could be one line of code
  col_name_computation_sub <- substitute(col_name_computation)
  res <- eval(col_name_computation_sub, envir = a)
  a$new_col <- res
  a
}
mutator(head(iris), Sepal.Length * 10)
  
```

(Of course, the real `dplyr::mutate` does A LOT more, it's juste for the example)

Let's sum up what is happening here : 

+ I give `a` and `new_col` an expression as input
+ Both `a` and `new_col` become promises, linked to the expressions given as input. None are evaluated at this point, thanks to lazy evaluation
+ The function extract the expression contained in `col_name_computation`, puts it in `col_name_computation_sub`, which is at that stage a `call`.
+ The function changes the rules of evaluation, and this `call` is evaluated in the context of the dataframe given (remember that dataframe are environment, and you can `eval` a symbol inside a data.frame). 
+ This newly created vector is put inside the dataframe
+ The modified data.frame is returned. 

```{r}
mutator <- function(a, col_name_computation){
  # In three steps here to detail the process, could be one line of code
  col_name_computation_sub <- substitute(col_name_computation)
  res <- eval(col_name_computation_sub, envir = a)
  a$new_col <- res
  cat("`col_name_computation_sub` is: ")
  print(col_name_computation_sub)
  cat("its class is: ")
  print(class(col_name_computation_sub))
  cat("`res` is: ")
  print(res)
}
mutator(head(iris), Sepal.Length * 10)
  
```

### What's hard with `promises`

Let's continue from

> Within the R language, promise objects are almost only seen implicitly: actual function arguments are of this type. There is also a delayedAssign function that will make a promise out of an expression. There is generally no way in R code to check whether an object is a promise or not, nor is there a way to use R code to determine the environment of a promise.